<!DOCTYPE html>
<html prefix="
        og: http://ogp.me/ns# article: http://ogp.me/ns/article#
    " vocab="http://ogp.me/ns" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>Lessons Learned from Making Call Center Calculator | Michael Deckebach</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#3e5042">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="canonical" href="https://michaeldeckebach.com/writing/lessons-learned-from-making-call-center-calculator/">
<link rel="icon" href="../../files/favicon-16x16.png" sizes="16x16">
<!--[if lt IE 9]><script src="../../assets/js/html5shiv-printshiv.min.js"></script><![endif]--><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=G-8HE6SJQ79H"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8HE6SJQ79H');
</script><meta name="author" content="Michael Deckebach">
<link rel="prev" href="../call-center-calculator/" title="Call Center Calculator" type="text/html">
<link rel="next" href="../pauls-tableau-dashboard/" title="Paul's Tableau Dashboard" type="text/html">
<meta property="og:site_name" content="Michael Deckebach">
<meta property="og:title" content="Lessons Learned from Making Call Center Calculator">
<meta property="og:url" content="https://michaeldeckebach.com/writing/lessons-learned-from-making-call-center-calculator/">
<meta property="og:description" content="Earlier this spring, I built a web app to show the differences between Erlang C and computer simulation methods for determining call center staffing requirements. Nerdy, I know.
It was a fun project t">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2022-05-29T18:25:21-07:00">
<meta property="article:tag" content="Data">
</head>
<body>
    <a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
    <div id="container">
            <header id="header"><h1 id="brand"><a href="../../" title="Michael Deckebach" rel="home">

        <span id="blog-title">Michael Deckebach</span>
    </a></h1>

        
            <nav id="menu"><ul>
<li><a href="../../adventures/">Adventures</a></li>
                <li><a href="../">Writing</a></li>

    
    
    
    </ul></nav></header><main id="content"><article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name" itemprop="headline name"><a href="." class="u-url">Lessons Learned from Making Call Center Calculator</a></h1>

        <div class="metadata">
            <p class="dateline">
                2022-05-29
            </p>
            <aside class="postpromonav"><ul itemprop="keywords" class="tags">
        Tags: 
            <li><a class="tag p-category" href="../../categories/data/" rel="tag">Data</a></li>
        </ul></aside>
</div>
        
    </header><div class="e-content entry-content" itemprop="articleBody text">
    <p>Earlier this spring, I built a web app to show the differences between Erlang C and computer simulation methods for determining call center staffing requirements. Nerdy, I know.</p>
<p>It was a fun project that combined much of my work at Patagonia over the past couple years (call center staffing) with some of my CS302 coursework (event-driven simulations).</p>
<p>Originally, I started the project in Python using Flask, but quickly realized that I could do everything I wanted client-side with JavaScript. Toss in some static HTML and CSS and you have a functioning web app. Pretty neat!</p>
<p>That's not to say that everything was roses and sunshine. Below are the three biggest hurdles I encountered working on this project, and what I learned as a result.</p>
<section id="event-class-overwriting"><h2>1. Event Class Overwriting</h2>
<p>When I first started tinkering with the idea of simulating a call center queue, I had no idea what I was doing. I created a naive loop like this, where each iteration represented one second in the time period:</p>
<pre class="literal-block">for second in total_seconds:
    if second in contact_start_times:
        make new contact + do stuff
    for contact in active_contacts:
        if contact.end_time = second
            do stuff</pre>
<p>While it worked, it wasn't efficient at all. Given 100 simulations per agent count, ~8 agent counts to test, 50 contacts, and a period of 30 minutes (1800 seconds), that means 100 x 8 x 50 x 1800 = <strong>72 million iterations!</strong></p>
<p>Fortunately, there is a better way. When covering queues (and priority queues) in my Data Structures course this past spring, we touched on the idea of an event-driven simulation. <strong>Epiphany: I didn't need to care about every second in a simulation, only those seconds where a call arrived or ended!</strong></p>
<p>The effect is that instead of 72 million iterations, I only needed 80 thousand (100 x 8 x 50 x 2). Much more manageable!</p>
<p>Armed with this knowledge, I did just that. I created an <code class="docutils literal">Event</code> class, where <code class="docutils literal">Event</code> represented either a call arriving or departing. I was cruising along and everything was going to be awesome.</p>
<p><strong>Then everything broke:</strong></p>
<figure><img alt="/images/writing/lessons-learned-from-making-call-center-calculator/img-1.jpg" src="../../images/writing/lessons-learned-from-making-call-center-calculator/img-1.jpg"></figure><p>I searched all over. I had been refactoring, did my <code class="docutils literal">Event</code> class definition exist in two separate files by chance? No. StackOverflow was a dead end. I was lost.</p>
<p>It took me a couple nights, probably 4-6 hours of debugging before the real problem finally dawned on me. It wasn't that I had defined my <code class="docutils literal">Event</code> class twice, it was that my custom <code class="docutils literal">Event</code> class was trying to redefine the DOM's <code class="docutils literal">Event</code> interface!</p>
<p><a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/API/Event">https://developer.mozilla.org/en-US/docs/Web/API/Event</a></p>
<p><em>Well, I felt like an idiot.</em></p>
<p>The good news was that all I had to do was rename my class to resolve the problem. But lesson learned: the hardest errors almost always involve some oversight or misassumption on the programmer's part.</p>
</section><section id="web-workers"><h2>2. Web Workers</h2>
<p>JavaScript is single threaded. (I learned) that when a script is running, no other scripts can run and the webpage appears frozen while any computation is done. Calculating Erlang C and computer simulated results can take 5-10 seconds, during which the website may appear frozen or stuck.</p>
<p>To provide a bit of feedback to the user, I thought to add a progress bar to the web app. However, how do I "update" it if JavaScript is single threaded?</p>
<p><strong>The answer is Web Workers.</strong> A Web Worker is an object that runs a JavaScript file in a background thread. This way, the thread can continue doing all calculations without affecting the user interface. Futhermore, the Web Worker can pass messages to and from the code in which it is created, which seemed like a perfect way to bring my progress bar idea to life.</p>
<p>I'm no expert, but here's what I ended up with:</p>
<pre class="literal-block">/**
* On Submit Functions - runs whenever form is submitted
*/

// Initialize worker and listener for form submission
var worker = null;
if (window.Worker) {
    worker = new Worker("/js/worker.js");
    document.getElementById('input_form').addEventListener('submit', startWorker);
} else {
    alert("Workers are not supported. Please use a different browser.");
}

// Start worker
function startWorker() {
    worker.postMessage(getInputs());
}

// Read form inputs into dictionary to pass to worker
function getInputs() {
    let dict = {
        &lt;get values from webform&gt;
    };
    return dict;
}</pre>
<div class="line-block">
<div class="line"><br></div>
<div class="line">This is from my main JavaScript file, which contains all eventListeners. Any time the form is submitted, it creates a Web Worker and passes it a dictionary containing all the form's input values.</div>
</div>
<p>The Worker itself is set up to receive this dict, then it triggers the underlying Erlang C and Simulation code in the calc() function. Periodically, throughout the calc() function it passes back a message containing its overall progress. The Simulation portion has much greater time complexity than Erlang C, so for simplicity sake I calculate progress as the % of the simulation.</p>
<pre class="literal-block">self.addEventListener("message", onMessageReceive);

function onMessageReceive(e) {
    let dict = e.data;
    calc(dict);
}

function calc(dict) {

    &lt;calculate Erlang C&gt;

   &lt;calculate simulation&gt; {
        // Update progress bar as you go
        var cur_progress = (Number(index) + 1) / x.length * 100;
        postMessage({type: "progress", value: cur_progress});
    }

    // Bundle everything up to pass back to main
    let results = {
        &lt;dict containing Erlang C and simulation results&gt;
    }
    postMessage({type: "complete", value: results});
}</pre>
<p>Finally, the main.js file has a simple switch function to take these progress updates and update the progress bar accordingly:</p>
<pre class="literal-block">/**
* On Message Receipt Functions - runs whenever worker sends progress update or completes
*/

// Listener for when worker sends a message back
worker.addEventListener("message", onMessageReceive);

function onMessageReceive(e) {
    switch (e.data.type) {
        case "start":
            break;
        case "progress":
            updateProgress(e.data.value);
            break;
        case "complete":
            updateProgress(100);
            updateChart('chart', e.data.value);
            break;
        case "debug":
            console.log(e.data);
            break;
    }
}</pre>
<p><a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers">Read more about Web Workers here</a>. Pretty cool stuff!</p>
</section><section id="js-import-importscript"><h2>3. JS import &amp; importScript</h2>
<p>Full disclosure:  originally I wrote all my JavaScript as one big file. I knew it was messy and figured I'd go back and clean things up later. Turns out, refactoring JavaScript is different than other languages like Python (where I was familiar with the idea of <code class="docutils literal">import package as pkg</code> commands).</p>
<p>I'll save the narrative, but I learned along the way that the way JavaScript files are imported is less straightforward, especially when dealing with Web Workers. The tl;dr is:</p>
<blockquote>
<ul class="simple">
<li><p><code class="docutils literal">import</code> statements can only appear on root files</p></li>
<li><p>worker files, in part because they are not root files, have to rely on the earlier <code class="docutils literal">importScripts</code> syntax.</p></li>
<li><p>To use <code class="docutils literal">import</code> statements, you have to include <code class="docutils literal"><span class="pre">type="module"</span></code> in the html tag.</p></li>
</ul>
</blockquote>
<p>After some trial and error, I ended up breaking my JavaScript into the following five files:</p>
<blockquote>
<ul class="simple">
<li><p><strong>main.js</strong> - top-level and called by the HTML. It contains all DOM event listeners and primarily serves as a controller between the page and underlying JS.</p></li>
<li><p><strong>chart.js</strong> - code to initialize and update the Plotly chart</p></li>
<li><p><strong>worker.js</strong> - code to receive and send messages to the Web Worker in main, as well as run the main calculations</p></li>
<li><p><strong>erlangc.js</strong> - functions for calculating staffing according to Erlang C methodology</p></li>
<li><p><strong>simulation.js</strong> - functions for calculating staffing according to a Simulation methodology</p></li>
</ul>
</blockquote>
<p>Is it good? I don't know. But it's an early programmer's attempt at staying modular and it works, so I'll give myself a passing grade.</p>
</section>
</div>
    
</article></main><footer id="footer"><p>© 2017-2023   |   <a href="mailto:michael.deckebach@gmail.com">michael.deckebach@gmail.com</a></p>
            
        </footer>
</div>
                <script src="../../assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
    </script>
</body>
</html>
